{"hash":"41452752fefa88bad284d1f2761f45ec58a3a74c","data":{"post":{"title":"Serveur HTTP 2 avec Go 1.6","date":"2 March 2016","content":"<p>Bonne nouvelle, depuis la version 1.6 de Go, il est possible d'implémenter le HTTP/2, autrement dit, le futur de HTTP/1.1 existant depuis plus d'une décennie (1994 pour la version 1 et de 1997 à 2014 pour la version 1.1). Cette nouvelle version siglée RFC 7540 propulse le chargement des fichiers en multiplexage avec des entêtes compressées. Autant vous dire que le temps de chargement est au rendez-vous pour la moyenne des sites actuels dont les pages pèsent environ 2 Mo avec 60 / 80 requêtes. Pas de panique, les methodes (GET, POST, PUT, DELETE, etc...) ne changent pas ainsi que les codes de statuts, les entêtes et la négociation.</p>\n<p><img class=\"g-image g-image--lazy g-image--loading\" src=\"data:image/svg+xml,%3csvg fill='none' viewBox='0 0 480 341' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-108'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='40'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-108)' width='480' height='341' xlink:href='data:image/jpeg%3bbase64%2c/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAtAEADASIAAhEBAxEB/8QAHAABAAICAwEAAAAAAAAAAAAABgEFAgMABAcI/8QANBAAAQIFAgQEAwcFAAAAAAAAAQIDAAQFBhESIRMiMVEHQXKxFZGhFBdSYWNxwSMyYqKy/8QAFwEBAQEBAAAAAAAAAAAAAAAAAQACA//EACQRAAIBAwIGAwAAAAAAAAAAAAECAAMRIRIxExRBUZHRBGGh/9oADAMBAAIRAxEAPwD6PWoIQpajhKQST2AjS9Py7LqWluHiHPKltSj0z5DsRHVr1Up9Mpy3KtMolpZz%2bkVLPUqBGPeCyb9sqnLTw65Io0rLgQ25kAlISdgOwjJqKuCZsIzZAi4VaSPCPG2dzwzoUAoAZJBxuPzjtS77UyjWysLTnBx5Hsfzga3e1oTMsgN1mX0ISEZUoglOQcbjzxvG2TvW0pNhQRcUmU5yrjTYUrPfffJiV1bYyalUXLAiMesRBhN/2spouCvU3QOqi%2bAPrGEv4g2vMqIZrUkrHU68D5kYhLqNzIUntexigxgonuYo6feVu1J7gyVZp7zv4EzCc/LMXLbrbydTTiFjulQPtAGDZECpG4lfdFu0y56aJCsy4flgsOBOccw6H6mCg8IbP0hIpriR/hMLT7EQ5nRMKQ19lKQvioKtfTRnm%2bkVqJWpLYXxpp5LxYUEltYCUualYIG%2b2nT1zj94SAd4h2XCmF/uds7fVTXF%2buYWr3Ma/uctVKSllqdYH6UwUkQ0lpF1l6ae4zilLaShpCnCUoOnf/bfO8diUTMIePGJKAy2kc2eYatR/wCd4iincSWrUXKkiAJbwZtZl3iONzb6/wATr2o/MjMbHvBy0XlEuSk0rPkqaWoD9sx6NqiCoQCkg6RNaoc6jPJJvwMoC1qMnUKpKpPRAdCgn5iEvh1YbNlIng1UZueVNKSSp/ACEpzgADbO5yYa5iIuGoNwJGtUYaSSRKi4JCrThZNHq4p%2bjOsKYDgX269IqPhV4oHLcUiv1SULhE5gKA5nRPkMg0gDwPUHGXvlrGioUV/1sLR7Rzj3y1/dJ0R/0vLT7wxiMxcP7Mea7qPHqDzVbxQOa3pJw/pzo/kRHx660DntQK9E4g/xDCIziLQe5hzC9aY/fcqbfqc9UEvfEaRMU1SCAkOrSrXnrjHaLbzjEqjArOY2BYZnFiGa4Fp//9k=' /%3e%3c/svg%3e\" width=\"480\" data-srcset=\"/assets/static/http1.1_vs_http2.82a2fbd.e2913c8.jpg 480w, /assets/static/http1.1_vs_http2.82a2fbd.e2913c8.jpg 480w\" data-sizes=\"(max-width: 480px) 100vw, 480px\" data-src=\"/assets/static/http1.1_vs_http2.82a2fbd.e2913c8.jpg\"><noscript><img class=\"g-image g-image--lazy g-image--loaded\" src=\"/assets/static/http1.1_vs_http2.82a2fbd.e2913c8.jpg\" width=\"480\"></noscript></p>\n<p>Pour pouvoir mettre en place HTTP/2, il faut exécuter le serveur avec le chiffrement TLS, autrement dit HTTPS.</p>\n<h2 id=\"préparation-de-la-clef-et-du-certificat\"><a href=\"#pr%C3%A9paration-de-la-clef-et-du-certificat\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Préparation de la clef et du certificat</h2>\n<p>Pour que TLS fonctionne correctement, il faut générer un fichier qui va contenir la clef publique et un certificat. On utilise l'utilitaire \"openssl\" à la racine du projet pour générer nos 2 fichiers.\nOn commence par générer la clef privée : <code class=\"language-text\">openssl genrsa -out localhost.key 2048</code> afin de générer le certificat : <code class=\"language-text\">openssl req -new -x509 -key localhost.key -out localhost.pem -days 730</code></p>\n<ul>\n<li>\"-x509\" : le cryptage utilisé ;</li>\n<li>\"-key localhost.key\" : le fichier de la clef publique ;</li>\n<li>\"out localhost.pem\" : le fichier du certificat ;</li>\n<li>\"-days 365\" : correspond au nombre de jour (ici 1 an) de validité du certificat.</li>\n</ul>\n<h2 id=\"configurer-http2\"><a href=\"#configurer-http2\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Configurer HTTP/2</h2>\n<p>Tout d'abord si votre version de Go (<code class=\"language-text\">go version</code>) est inférieur à la 1.6, il faut télécharger la librairie mise à disposition pour HTTP/2 : <code class=\"language-text\">go get golang.org/x/net/http2</code> pour l'importer avec les autres librairies dont nous aurons besoin par la suite.</p>\n<pre class=\"language-golang\"><code class=\"language-golang\">package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n\n    // Go < 1.6\n    \"golang.org/x/net/http2\"\n)</code></pre>\n<p>Si vous travaillez sur la version 1.6 ou +, vous n'avez pas besoin de suivre cette partie.<br>\nDans la fonction principale \"main()\", on déclare une variable \"s\" de type \"http.Server\". On active les logs dans le terminal du serveur en passant la valeur de \"http2.VerboseLogs\" à \"true\" sans oublier \"http2.ConfigureServer\" dans laquelle on met en premier paramètre l'expression \"&#x26;s\" et en second \"nil\".</p>\n<pre class=\"language-golang\"><code class=\"language-golang\">func main() {\n    // Configuration de HTTP2 pour Go < 1.6\n    var s http.Server\n    http2.VerboseLogs = true\n    http2.ConfigureServer(&s, nil)\n\n    // Suite du code\n)</code></pre>\n<h2 id=\"création-et-appel-dune-route\"><a href=\"#cr%C3%A9ation-et-appel-dune-route\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Création et appel d'une route</h2>\n<p>Pour afficher un résultat dans la route d'accueil, on créé une nouvelle fonction \"indexHandler\" avec les paramètres de la librairie http (\"w http.ResponseWriter, r *http.Request\").</p>\n<pre class=\"language-golang\"><code class=\"language-golang\">// Route d'accueil\nfunc indexHandler(w http.ResponseWriter, r *http.Request) {\n    w.Header().Set(\"Content-Type\", \"text/plain; charset=UTF-8\")\n    fmt.Fprintln(w, \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\")\n}</code></pre>\n<p>Rien d'extraordinaire, on affiche seulement du texte au format UTF-8 via \"fmt.Fprintln()\". Puis dans notre fonction \"main()\", on appelle cette route dans la fonction \"http.HandleFunc()\".</p>\n<pre class=\"language-golang\"><code class=\"language-golang\">func main() {\n    // Configuration de HTTP2 pour Go < 1.6\n    var s http.Server\n    http2.VerboseLogs = true\n    http2.ConfigureServer(&s, nil)\n\n    // Appel de la route d'accueil\n    http.HandleFunc(\"/\", indexHandler)\n\n    // Suite du code\n}</code></pre>\n<h2 id=\"listenandservetls\"><a href=\"#listenandservetls\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>ListenAndServeTLS</h2>\n<p>Maintenant que l'on a activé HTTP 2 et appelé notre unique route, il ne manque plus que le \"démarreur\" de notre serveur. Pour cela on utilise, la fonction \"http.ListenAndServeTLS()\" dans laquelle on indique le port (443 par défaut), le nom de notre certificat (\"localhost.pem\"), la clef publique (\"localhost.key\") et \"nil\".</p>\n<pre class=\"language-golang\"><code class=\"language-golang\">func main() {\n    // Configuration de HTTP2 pour Go < 1.6\n    var s http.Server\n    http2.VerboseLogs = true\n    http2.ConfigureServer(&s, nil)\n\n    // Appel de la route d'accueil\n    http.HandleFunc(\"/\", indexHandler)\n\n    // Lancement du serveur HTTPS\n    err := http.ListenAndServeTLS(\":443\", \"localhost.pem\", \"localhost.key\", nil)\n    if err != nil {\n        log.Fatal(\"ListenAndServe: \", err)\n    }\n}</code></pre>\n<p>S'il y a une erreur au lancement du serveur (mauvais paramètre, fichier manquant, etc..) elle s'affichera grâce à \"log.Fatal()\".</p>\n<h2 id=\"lancement-du-serveur\"><a href=\"#lancement-du-serveur\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Lancement du serveur</h2>\n<p>Lancez votre serveur avec <code class=\"language-text\">go run main.go</code>.</p>\n<p>Dans votre navigateur Internet, accédez à votre serveur via <a href=\"https://localhost\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://localhost</a> (et non <a href=\"http://localhost\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http://localhost</a> !!!). A la première connexion, vous devez accepter le certificat demandé par votre navigateur.</p>\n<p>Remarque : votre navigateur vous informe que le certificat est dangereux. C'est tout à fait juste car ce dernier n'est pas signé par une autorité compétente.</p>\n<h3 id=\"linux\"><a href=\"#linux\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Linux</h3>\n<p>Sur Linux lorsque vous tentez de lancez le serveur avec le port 443 vous avez le droit à l'erreur suivante : <code class=\"language-text\">ListenAndServe: listen tcp :443: bind: permission denied</code>. En effet, il faut lancer la commande avec les privilèges de sudo.\nPour résoudre ce problème d'autorisation, ouvrez le fichier de configuration de l'utilitaire sudo : <code class=\"language-text\">sudo vim /etc/sudoers</code> et ajoutez les 2 lignes ci-dessous :</p>\n<pre class=\"language-text\"><code class=\"language-text\">Defaults env_keep +=&quot;GOPATH&quot;\nDefaults env_keep +=&quot;GOROOT&quot;</code></pre>\n<p>Puis enregistrez cette modification avec \"wq!\" et lancez le serveur avec <code class=\"language-text\">sudo go run main.go</code>.</p>\n<h2 id=\"sources\"><a href=\"#sources\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Sources</h2>\n<ul>\n<li>Fonction ConfigureServer de golang.org/x/net/http2 : <a href=\"https://godoc.org/golang.org/x/net/http2#ConfigureServer\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://godoc.org/golang.org/x/net/http2#ConfigureServer</a></li>\n<li>Fonction ListenAndServeTLS : <a href=\"https://golang.org/pkg/net/http/#ListenAndServeTLS\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://golang.org/pkg/net/http/#ListenAndServeTLS</a></li>\n<li>A propos du fichier sudoers <a href=\"https://doc.ubuntu-fr.org/sudoers\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://doc.ubuntu-fr.org/sudoers</a></li>\n<li>Des outils pour tester HTTP 2<a href=\"https://blog.cloudflare.com/tools-for-debugging-testing-and-using-http-2\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://blog.cloudflare.com/tools-for-debugging-testing-and-using-http-2</a></li>\n<li>\"HTTP/2 : quels sont les nouveautés et les gains ?\" <a href=\"https://devcentral.f5.com/articles/http2-est-l-quels-sont-les-gains-14945\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://devcentral.f5.com/articles/http2-est-l-quels-sont-les-gains-14945</a></li>\n</ul>\n"}},"context":{}}