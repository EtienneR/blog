{"hash":"a6a83eeab333c7bbcf47fff9751f8c5dda4260fc","data":{"post":{"title":"Créer une API RESTful sur Go","date":"24 February 2017","content":"<p>Une API (Application Programming Interface) permet de fournir des données brutes accessibles depuis une URL. En général, cela permet de faire le pont entre une application cliente et une base de données, dans notre cas depuis SQLite. Pourquoi le choix de cette base ? Car SQLite est un système de base de données en SQL qui a pour principal atout de fonctionner sans serveur car les données sont contenues dans un fichier. Avec certes moins d'options mais cela est suffisant dans notre cas.</p>\n<p>Dans l'API que nous allons mettre en place, les données seront fournies à l'utilisateur final au format JSON (JavaScript Object Notation). Nous allons aussi réaliser des tests unitaires et configurer le serveur afin qu'il soit accessible pour les navigateurs Internet.</p>\n<p>Prérequis nécessaires :</p>\n<ul>\n<li>Go et Git installés ;</li>\n<li>Avoir des bases en Go ;</li>\n<li>Notions de requêtes CRUD en SQL et en HTTP;</li>\n</ul>\n<p>Prérequis optionnels :</p>\n<ul>\n<li>Avoir lu ce tutoriel : <a href=\"http://zestedesavoir.com/tutoriels/299/la-theorie-rest-restful-et-hateoas\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http://zestedesavoir.com/tutoriels/299/la-theorie-rest-restful-et-hateoas</a> ;</li>\n<li>L'application <a href=\"https://www.getpostman.com\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Postman</a> installée.</li>\n</ul>\n<p>Objectifs :</p>\n<ul>\n<li>Créer une API RESTful sur Go avec des requêtes en SQL via un ORM ;</li>\n<li>Réaliser des tests fonctionnels et unitaires ;</li>\n<li>Configurer CORS, OPTIONS, ajouter un token d'authentification.</li>\n</ul>\n<h2 id=\"préparation-du-dossier-de-travail\"><a href=\"#pr%C3%A9paration-du-dossier-de-travail\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Préparation du dossier de travail</h2>\n<p>Dans votre dossier \"gopath\" (<code class=\"language-text\">%gopath%</code> sur Windows, <code class=\"language-text\">$GOPATH</code> sur Linux et MacOS), dans le dossier \"src\" puis \"github.com\", votre nom d'utilisateur (dans ce tutoriel, ce sera \"EtienneR\") et créez un nouveau dossier (\"go_sqlite_api\" dans ce tutoriel). Le dossier de notre projet va comporter un fichier \"main.go\" contenant notre serveur et un dossier \"api\" avec les fichiers \"api.go\", \"users.go\" et le fichier de tests unitaires \"users_test.go\". Par la suite, le fichier SQLite \"data.db\" sera créé automatiquement.</p>\n<pre class=\"language-text\"><code class=\"language-text\">gopath/\n  src/\n    github.com/\n        EtienneR/\n            go_sqlite_api/\n                api/\n                    api.go\n                    users.go\n                    users_test.go\n                main.go\n                data.db</code></pre>\n<h3 id=\"les-librairies\"><a href=\"#les-librairies\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Les librairies</h3>\n<p>Pour mettre en place cette API, on a besoin des 3 librairies ci-dessous.</p>\n<ul>\n<li>Gin : le micro framework basé sur HttpRouter <code class=\"language-text\">go get github.com/gin-gonic/gin</code> ;</li>\n<li>go-sqlite3 : le \"driver\" (pilote en français) SQLite3 <code class=\"language-text\">go get github.com/mattn/go-sqlite3</code> ;</li>\n<li>Gorm : l'ORM (Object-Relational Mapping) <code class=\"language-text\">go get github.com/jinzhu/gorm</code>.</li>\n</ul>\n<p>Dans le fichier \"api.go\", on appel ces librairies dans \"import\".</p>\n<pre class=\"language-golang\"><code class=\"language-golang\">package api\n\nimport (\n    \"github.com/gin-gonic/gin\"\n    \"github.com/jinzhu/gorm\"\n    _ \"github.com/mattn/go-sqlite3\"\n)</code></pre>\n<p>Remarque : le pilote SQLite3 est indispensable pour faire fonctionner l'ORM. Gorm accepte également <strong>MySQL</strong> (et <strong>MariaDB</strong>), <strong>Postgres</strong> et <strong>FoundationDB</strong> à condition d'avoir à disposition le pilote correspondant.</p>\n<h3 id=\"préparation-de-la-base-de-données\"><a href=\"#pr%C3%A9paration-de-la-base-de-donn%C3%A9es\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Préparation de la base de données</h3>\n<p>Pour créer notre futur fichier de base de donnée SQLite \"data.db\", on va avoir recours à l'ORM, Gorm.</p>\n<h4 id=\"structure-de-données\"><a href=\"#structure-de-donn%C3%A9es\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Structure de données</h4>\n<p>Pour la structure dans notre fichier \"users.go\", on reprend le nom de la table concernée \"users\" ainsi que les 2 champs \"id\" et \"name\".</p>\n<pre class=\"language-golang\"><code class=\"language-golang\">package api\n\nimport (\n    \"github.com/gin-gonic/gin\"\n)\n\ntype Users struct {\n    Id   int    `gorm:\"AUTO_INCREMENT\" form:\"id\" json:\"id\"`\n    Name string `gorm:\"not null\" form:\"name\" json:\"name\"`\n}</code></pre>\n<p>On met en place le \"databinding\" pour les données rentrées (POST et PUT) avec <code class=\"language-text\">json:&quot;id&quot;</code> et <code class=\"language-text\">json:&quot;name&quot;</code>. Si cette notion vous parait abstraite, vous comprendrez son principe lors de l'utilisation des routes concernées. Concernant <code class=\"language-text\">form:&quot;id&quot;</code> et <code class=\"language-text\">form:&quot;name&quot;</code>, ils permettent de récupérer les données depuis \"form-data\" et \"x-www-form-urlencoded\" disponibles dans Postman. Quant à \"gorm\", ce sont des paramêtres de configuration dédiés à la création des champs concernés.`</p>\n<h4 id=\"initialisation-de-la-base-de-données\"><a href=\"#initialisation-de-la-base-de-donn%C3%A9es\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Initialisation de la base de données</h4>\n<p>Pour se connecter à la base de données, dans le fichier \"api.go\", on indique le pilote utilisé \"sqlite3\" et le chemin du fichier \"data.db\".</p>\n<pre class=\"language-golang\"><code class=\"language-golang\">func InitDb() *gorm.DB {\n    // Ouverture du fichier\n    db, err := gorm.Open(\"sqlite3\", \"./data.db\")\n    db.LogMode(true)\n\n    // Création de la table\n    if !db.HasTable(&Users{}) {\n        db.CreateTable(&Users{})\n        db.Set(\"gorm:table_options\", \"ENGINE=InnoDB\").CreateTable(&Users{})\n    }\n\n    // Erreur de chargement\n    if err != nil {\n        panic(err)\n    }\n\n    return db\n}</code></pre>\n<p>Dans la première condition, si la table \"users\" n'existe pas, alors on l'a créé avec les options déclarées dans la structure \"Users\" ainsi que le moteur SQL \"InnoDB\".<br>\nLa fonction facultative mais utile en phase de développement <code class=\"language-text\">db.LogMode(true)</code> permet d'afficher la ou les requête(s) effectuée(s) dans le terminal.</p>\n<h3 id=\"création-du-serveur\"><a href=\"#cr%C3%A9ation-du-serveur\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Création du serveur</h3>\n<p>Dans le fichier \"main.go\", on déploit un serveur HTTP fonctionnant sur le port 3000 et dont les routes seront déclarées dans le package \"api\", dans le fichier \"api.go\".</p>\n<pre class=\"language-golang\"><code class=\"language-golang\">package main\n\nimport (\n    \"log\"\n    \"net/http\"\n\n    \"github.com/EtienneR/go_sqlite_api/api\"\n)\n\nfunc main() {\n    err := http.ListenAndServe(\":3000\", api.Handlers())\n\n    if err != nil {\n        log.Fatal(\"ListenAndServe: \", err)\n    }\n}</code></pre>\n<p>Remarque : en production, il faudra remplacer le port 3000 par 80.</p>\n<p>Vous l'avez compris, à ce stade, le serveur ne fonctionne pas car on n'a pas encore travaillé dans le fichier \"api.go\". On ne touchera plus au fichier \"main.go\".</p>\n<h2 id=\"le-routage\"><a href=\"#le-routage\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Le routage</h2>\n<p>Dans cette partie, on va faire le plus gros, c'est-à-dire déclarer nos routes avec les requêtes SQL correspondantes en prenant soin de prendre en compte les erreurs éventuelles qui surviennent lors de l'appelation et l'envoi des données. Nous testerons nos routes avec Postman sauf si vous préférez CURL et sa syntaxe...</p>\n<h3 id=\"objectifs\"><a href=\"#objectifs\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Objectifs</h3>\n<p>On va utiliser 5 routes basiques de CRUD (Create, Read, Update, Delete) listées ci-dessous.</p>\n<table>\n<thead>\n<tr>\n<th>Verbe</th>\n<th>URL</th>\n<th>Action</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GET</td>\n<td>/api/v1/users</td>\n<td>Lister tous les utilisateurs</td>\n</tr>\n<tr>\n<td>GET</td>\n<td>/api/v1/users/1</td>\n<td>Lister l'utilisateur #1</td>\n</tr>\n<tr>\n<td>POST</td>\n<td>/api/v1/users</td>\n<td>Poster un nouvel utilisateur</td>\n</tr>\n<tr>\n<td>PUT</td>\n<td>/api/v1/users/1</td>\n<td>Modifier l'utilisateur #1</td>\n</tr>\n<tr>\n<td>DELETE</td>\n<td>/api/v1/users/1</td>\n<td>l'utilisateur #1</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"préparation\"><a href=\"#pr%C3%A9paration\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Préparation</h3>\n<p>A la suite (dans le fichier \"api.go\"), dans une nouvelle fonction nommée <code class=\"language-text\">Handlers()</code>, on fait appel au micro-framework Gin pour déclarer nos routes.</p>\n<pre class=\"language-golang\"><code class=\"language-golang\">func Handlers() *gin.Engine {\n    r := gin.Default()\n\n    v1Users := r.Group(\"api/v1/users\")\n    {\n        v1Users.POST(\"\", PostUser)\n        v1Users.GET(\"\", GetUsers)\n        v1Users.GET(\":id\", GetUser)\n        v1Users.PUT(\":id\", EditUser)\n        v1Users.DELETE(\":id\", DeleteUser)\n    }\n\n    return r\n}</code></pre>\n<p>Dans un premier temps, on instancie le serveur MUX dans une variable (r). Sachant que les URL de notre API commencent par le même chemin, le \"endpoint\" <code class=\"language-text\">api/v1/users</code>, on déclare un groupe pour nos routes dans une variable (<code class=\"language-text\">v1Users</code>). C'est dans cette fonction que l'on placera nos routes. Et on retourne les données de notre routeur MUX car on en a besoin dans notre fichier \"main.go\". Pour mieux organiser notre code, nous allons créer les fonctions de nos routes dans le fichier \"users.go\".</p>\n<h3 id=\"ajouter-un-nouvel-utilisateur\"><a href=\"#ajouter-un-nouvel-utilisateur\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Ajouter un nouvel utilisateur</h3>\n<p>Pour insérer des données, on veut effectuer la requête SQL semblable à celle ci-dessous.</p>\n<pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> <span class=\"token string\">\"users\"</span> <span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span> <span class=\"token keyword\">VALUES</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"toto\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>On met en place une route de type POST dans la fonction <code class=\"language-text\">PostUser</code>.</p>\n<pre class=\"language-golang\"><code class=\"language-golang\">// Ajouter un utilisteur\nfunc PostUser(c *gin.Context) {\n    db := InitDb()\n    defer db.Close()\n\n    var json Users\n    c.Bind(&json)\n\n    // Si le champ est bien saisi\n    if json.Name != \"\" {\n        // INSERT INTO \"users\" (name) VALUES (json.Name);\n        db.Create(&json)\n        // Affichage des données saisies\n        c.JSON(201, gin.H{\"success\": json})\n    } else {\n        // Affichage de l'erreur\n        c.JSON(422, gin.H{\"error\": \"Fields are empty\"})\n    }\n}</code></pre>\n<p>Dans un premier temps, on récupère les données rentrées en JSON via la fonction <code class=\"language-text\">c.Bind()</code>. Puis on vérifie si le champ \"name\" n'est pas vide alors on envoie un message de succès avec le code HTTP \"201\". Sinon on renvoie le code \"422\" avec un message d'erreur.</p>\n<p>Dans Postman, sélectionnez \"POST\" puis l'URL \"<a href=\"http://localhost:3000/api/v1/users%22\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http://localhost:3000/api/v1/users\"</a>, cochez \"Body\" puis \"raw\", sélectionnez \"JSON (application/json)\" et copiez les données à rentrer <code class=\"language-text\">{ &quot;name&quot;: &quot;John Doe&quot; }</code> et cliquez sur \"Send\".</p>\n<p>Attention : pour que \"form-data\" et \"x-www-form-urlencoded\" fonctionnent correctement, il ne faut pas qu'il y'ait d'en-têtes HTTP dans \"Headers\".</p>\n<h3 id=\"lister-tous-les-utilisateurs\"><a href=\"#lister-tous-les-utilisateurs\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Lister tous les utilisateurs</h3>\n<p>On veut afficher dans un tableau JSON tous les utilisateurs présents dans la table \"users\" ce qui revient à faire en SQL.</p>\n<pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> users<span class=\"token punctuation\">;</span></code></pre>\n<p>On met en place une route de type GET dans la fonction <code class=\"language-text\">GetUsers</code>.`</p>\n<pre class=\"language-golang\"><code class=\"language-golang\">// Obtenir la liste de tous les utilisateurs\nfunc GetUsers(c *gin.Context) {\n    db := InitDb()\n    defer db.Close()\n\n    var users []Users\n    // SELECT * FROM users\n    db.Find(&users)\n    // Affichage des données\n    c.JSON(200, users)\n}</code></pre>\n<p>On créé une variable <code class=\"language-text\">users</code> héritée de la structure du même nom en précisant que l'on souhaite un tableau (crochets ouvrant et fermant). Puis on effectue la requête SQL et on appel le résultat dans un appel au format JSON via la fonction <code class=\"language-text\">c.JSON()</code>.</p>\n<h3 id=\"lister-un-utilisateur\"><a href=\"#lister-un-utilisateur\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Lister un utilisateur</h3>\n<p>On veut afficher les données d'un utilisateur ce qui revient à faire en SQL.</p>\n<pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> users <span class=\"token keyword\">WHERE</span> id <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></code></pre>\n<p>On met en place une route de type GET avec l'id en paramètre dans la fonction <code class=\"language-text\">GetUser</code>.</p>\n<pre class=\"language-golang\"><code class=\"language-golang\">// Obtenir un utilisateur par son id\nfunc GetUser(c *gin.Context) {\n    db := InitDb()\n    defer db.Close()\n\n    id := c.Params.ByName(\"id\")\n    var user Users\n    // SELECT * FROM users WHERE id = 1;\n    db.First(&user, id)\n\n    if user.Id != 0 {\n        // Affichage des données\n        c.JSON(200, user)\n    } else {\n        // Affichage de l'erreur\n        c.JSON(404, gin.H{\"error\": \"User not found\"})\n    }\n}</code></pre>\n<p>Dans un premier temps, on stocke l'id concerné dans la variable <code class=\"language-text\">id</code> via la fonction <code class=\"language-text\">c.Params.ByName(&quot;id&quot;)</code>. Puis on vérifie que la requête SQL renvoie un résultat dans une ligne sinon on affiche une erreur 404 avec un message d'erreur personnalisé.`</p>\n<h3 id=\"modifier-un-utilisateur\"><a href=\"#modifier-un-utilisateur\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Modifier un utilisateur</h3>\n<p>Pour modifier des données, on veut effectuer la requête SQL.</p>\n<pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">UPDATE</span> users <span class=\"token keyword\">SET</span> name<span class=\"token operator\">=</span><span class=\"token string\">'toto2'</span> <span class=\"token keyword\">WHERE</span> id <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></code></pre>\n<p>On met en place une route de type PUT avec l'id en paramètre dans la fonction <code class=\"language-text\">EditUser</code>.</p>\n<pre class=\"language-golang\"><code class=\"language-golang\">// Modifier un utilisateur\nfunc EditUser(c *gin.Context) {\n    db := InitDb()\n    defer db.Close()\n\n    id := c.Params.ByName(\"id\")\n    var user Users\n    // SELECT * FROM users WHERE id = 1;\n    db.First(&user, id)\n\n    if user.Name != \"\" {\n        if user.Id != 0 {\n            var json Users\n            c.Bind(&json)\n\n            result := Users{\n                Id:   user.Id,\n                Name: json.Name,\n            }\n            // UPDATE users SET name='json.Name' WHERE id = user.Id;\n            db.Model(&user).Update(\"name\", result.Name)\n            // Affichage des données modifiées\n            c.JSON(200, gin.H{\"success\": result})\n        } else {\n            // Affichage de l'erreur\n            c.JSON(404, gin.H{\"error\": \"User not found\"})\n        }\n\n    } else {\n        // Affichage de l'erreur\n        c.JSON(422, gin.H{\"error\": \"Fields are empty\"})\n    }\n}</code></pre>\n<p>Dans un premier temps, on stocke l'id concerné dans la variable <code class=\"language-text\">id</code> via la fonction <code class=\"language-text\">c.Params.ByName(&quot;id&quot;)</code>. Comme dans la fonction précédente, on vérifie si le champ \"name\" n'est pas vide alors on envoie les données avec un message de succès de code HTTP \"201\". Sinon on renvoie une erreur \"422\" avec un message d'erreur. Puis on vérifie que la requête SQL renvoie un résultat, sinon on affiche une erreur 404 avec un message d'erreur personnalisé. Et pour finir, on insère les données via <code class=\"language-text\">db.Model().Update()</code>.</p>\n<p>Dans Postman, sélectionnez \"PUT\" puis l'URL \"<a href=\"http://localhost:3000/api/v1/users/1%22\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http://localhost:3000/api/v1/users/1\"</a>, cochez \"Body\" puis \"raw\" et copiez les données à rentrer <code class=\"language-text\">{ &quot;name&quot;: &quot;John la Frite&quot; }</code> et cliquez sur \"Send\".</p>\n<h3 id=\"supprimer-un-utilisateur\"><a href=\"#supprimer-un-utilisateur\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Supprimer un utilisateur</h3>\n<p>Pour supprimer un utilisateur, on veut effectuer la requête SQL ci-dessous.</p>\n<pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">DELETE</span> <span class=\"token keyword\">FROM</span> users <span class=\"token keyword\">WHERE</span> id <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></code></pre>\n<p>On met en place une route de type DELETE avec l'id en paramètre dans la fonction <code class=\"language-text\">DeleteUser</code>.</p>\n<pre class=\"language-golang\"><code class=\"language-golang\">// Supprimer un utilisateur\nfunc DeleteUser(c *gin.Context) {\n    db := InitDb()\n    defer db.Close()\n\n    // Récupération de l'id dans une variable\n    id := c.Params.ByName(\"id\")\n    var user Users\n    db.First(&user, id)\n\n    if user.Id != 0 {\n        // DELETE FROM users WHERE id = user.Id\n        db.Delete(&user)\n        // Affichage des données\n        c.JSON(200, gin.H{\"success\": \"User #\" + id + \" deleted\"})\n    } else {\n        // Affichage de l'erreur\n        c.JSON(404, gin.H{\"error\": \"User not found\"})\n    }\n}</code></pre>\n<p>Dans un premier temps, on stocke l'id concerné dans la variable <code class=\"language-text\">id</code> via la fonction <code class=\"language-text\">c.Params.ByName(&quot;id&quot;)</code>. Puis, comme pour la route précédente, on vérifie que l'utilisateur existe sinon on affiche une erreur 404 avec un message d'erreur personnalisé. Si l'utilisateur existe alors on le supprime avec <code class=\"language-text\">db.Delete()</code> et on affiche un message de succès.</p>\n<p>Dans Postman, sélectionnez \"DELETE\" puis l'URL \"<a href=\"http://localhost:3000/api/v1/users/1\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http://localhost:3000/api/v1/users/1</a>\" et cliquez sur \"Send\".</p>\n<h2 id=\"tests-unitaires\"><a href=\"#tests-unitaires\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Tests unitaires</h2>\n<p><img src=\"https://i.giphy.com/56LhCE2j6Uy2Y.gif\"></p>\n<p>Jusqu'ici, on a exécuté des tests fonctionnels avec Postman. Finalement, il est possible de s'en passer en effectuant une batterie de tests. Concretement, dans un fichier on va effectuer les mêmes taches que l'on a exécuté sur Postman mais de manière automatisées. Pour ce faire, on va donc travailler dans le fichier dédié, \"users_test.go\".</p>\n<h3 id=\"librairies-et-variables-globales\"><a href=\"#librairies-et-variables-globales\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Librairies et variables globales</h3>\n<p>On importe un certain nombre de librairies dont l'indispensable \"testing\" pour n'importe quel test sur Go ainsi que \"net/http\" et \"net/http/httptest\" pour des applications orientées Web. On déclare aussi des variables globales qui vont nous servir dans nos différentes fonctions.</p>\n<pre class=\"language-golang\"><code class=\"language-golang\">package api_test\n\nimport (\n    \"io\"\n    \"net/http\"\n    \"net/http/httptest\"\n    \"strings\"\n    \"testing\"\n\n     \"github.com/EtienneR/go_sqlite_api/api\"\n)\n\nvar (\n    server               *httptest.Server\n    reader               io.Reader\n    usersUrl, usersUrlId string\n    userId               int\n)</code></pre>\n<h3 id=\"initialisation\"><a href=\"#initialisation\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Initialisation</h3>\n<p>Lorsqu'on lance une batterie de tests, on se base sur une base de données vide afin d'éviter les problèmes avec l'auto-increment des id. Pour cela on supprime la table et on l'a créé avec des utilisateurs. Dans notre cas, ce sera un fichier \"data.db\" dans le dossier \"api\". Ensuite, on démarre un serveur HTTP de test basé sur nos routes. Dans 2 variables, on stocke les URL (la première sans le paramêtre \"id\" et la seconde avec).</p>\n<pre class=\"language-golang\"><code class=\"language-golang\">func init() {\n    // Ouverture de la connexion vers la BDD SQLite\n    db := api.InitDb()\n    // Fermeture de la connexion vers la BDD SQLite\n    defer db.Close()\n\n    var user api.Users\n\n    // Suppression de la table\n    db.DropTable(user)\n    // Création de la table\n    db.CreateTable(user)\n\n    // Création d'utilisateurs\n    db.Create(&api.Users{Name: \"Pierre\"})\n    db.Create(&api.Users{Name: \"Paul\"})\n    db.Create(&api.Users{Name: \"Jacques\"})\n    db.Create(&api.Users{Name: \"Marie Thérèse\"})\n\n    // Démarrage du serveur HTTP\n    server = httptest.NewServer(api.Handlers())\n\n    // URL sans paramêtre et avec\n    usersUrl = server.URL + \"/api/v1/users\"\n    usersUrlId = usersUrl + \"/5\"\n}</code></pre>\n<h3 id=\"fonctions-de-test\"><a href=\"#fonctions-de-test\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Fonctions de test</h3>\n<p>Comme dans notre test fonctionnel, on va tester chacune des routes de notre API.</p>\n<h4 id=\"tester-lajout-dune-ligne\"><a href=\"#tester-lajout-dune-ligne\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Tester l'ajout d'une ligne</h4>\n<pre class=\"language-golang\"><code class=\"language-golang\">func TestPostUser(t *testing.T) {\n    // Contenu à soumettre\n    userJson := `{\"name\": \"Donovan\"}`\n\n    // Contenu à soumettre au bon format\n    reader = strings.NewReader(userJson)\n\n    // Déclaration de la requête : type, URL, contenu\n    request, err := http.NewRequest(\"POST\", usersUrl, reader)\n    // Requête de type JSON\n    request.Header.Set(\"Content-Type\", \"application/json\")\n\n    // Exécution de la requête\n    response, err := http.DefaultClient.Do(req)\n\n    // Erreur si route inacessible\n    if err != nil {\n        t.Error(err)\n    }\n\n    // Erreur si code HTTP différent de 201\n    if response.StatusCode != 201 {\n        t.Errorf(\"Success expected: %d\", response.StatusCode)\n    }\n}</code></pre>\n<ol>\n<li>On stocke dans une variable le contenu de la ligne que l'on souhaite ajouter ;</li>\n<li>On modifie ce contenu pour le rendre lisible au format \"NewReader\" ;</li>\n<li>\n<p>On déclare la requête avec 3 paramètres :</p>\n<ul>\n<li>le type de la route : \"POST\" ;</li>\n<li>l'URL de la route ;</li>\n<li>le contenu ;</li>\n</ul>\n</li>\n<li>On spécifie ce contenu au format JSON (afin d'éviter une erreur HTTP 422) ;</li>\n<li>S'il y a une erreur pour contacter la route, alors le test affichera une erreur ;</li>\n<li>Si le code HTTP n'est pas 201 alors le test affichera une erreur.</li>\n</ol>\n<h4 id=\"tester-la-lecture-des-lignes\"><a href=\"#tester-la-lecture-des-lignes\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Tester la lecture des lignes</h4>\n<pre class=\"language-golang\"><code class=\"language-golang\">func TestGetUsers(t *testing.T) {\n    // Contenu à soumettre vide\n    reader = strings.NewReader(\"\")\n\n    // Déclaration de la reqûête : type, URL, contenu\n    request, err := http.NewRequest(\"GET\", usersUrl, reader)\n\n    // Exécution de la requête\n    response, err := http.DefaultClient.Do(request)\n\n    // Erreur si route inacessible\n    if err != nil {\n        t.Error(err)\n    }\n\n    // Erreur si code HTTP différent de 200\n    if response.StatusCode != 200 {\n        t.Errorf(\"Success expected: %d\", response.StatusCode)\n    }\n}</code></pre>\n<ol>\n<li>On stocke dans une variable aucun contenu;</li>\n<li>\n<p>On déclare la requête avec 3 paramètres :</p>\n<ul>\n<li>le type de la route : \"GET\" ;</li>\n<li>l'URL de la route ;</li>\n<li>le contenu (aucun) ;</li>\n</ul>\n</li>\n<li>S'il y a une erreur pour contacter la route, alors le test affichera une erreur ;</li>\n<li>Si le code HTTP n'est pas 200 alors le test affichera une erreur.</li>\n</ol>\n<h4 id=\"tester-la-lecture-dune-ligne\"><a href=\"#tester-la-lecture-dune-ligne\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Tester la lecture d'une ligne</h4>\n<pre class=\"language-golang\"><code class=\"language-golang\">func TestGetUser(t *testing.T) {\n    // Contenu à soumettre vide\n    reader = strings.NewReader(\"\")\n\n    // Déclaration de la requête : type, URL, contenu\n    request, err := http.NewRequest(\"GET\", usersUrlId, reader)\n\n    // Exécution de la requête\n    response, err := http.DefaultClient.Do(request)\n\n    // Erreur si route inacessible\n    if err != nil {\n        t.Error(err)\n    }\n\n    // Erreur si code HTTP différent de 200\n    if response.StatusCode != 200 {\n        t.Errorf(\"Success expected: %d\", response.StatusCode)\n    }\n}</code></pre>\n<ol>\n<li>On stocke dans une variable aucun contenu;</li>\n<li>\n<p>On déclare la requête avec 3 paramètres :</p>\n<ul>\n<li>le type de la route : \"GET\" ;</li>\n<li>l'URL de la route avec l'id en paramètre ;</li>\n<li>le contenu (aucun) ;</li>\n</ul>\n</li>\n<li>S'il y a une erreur pour contacter la route, alors le test affichera une erreur ;</li>\n<li>Si le code HTTP n'est pas 200 alors le test affichera une erreur.</li>\n</ol>\n<h4 id=\"tester-la-modification-dune-ligne\"><a href=\"#tester-la-modification-dune-ligne\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Tester la modification d'une ligne</h4>\n<pre class=\"language-golang\"><code class=\"language-golang\">func TestEditUser(t *testing.T) {\n    // Contenu à soumettre\n    userJson := `{\"name\": \"Mark\"}`\n\n    // Contenu à soumettre au bon format\n    reader = strings.NewReader(userJson)\n\n    // Déclaration de la requête : type, URL, contenu\n    request, err := http.NewRequest(\"PUT\", usersUrlId, reader)\n    // Requête de type JSON\n    request.Header.Set(\"Content-Type\", \"application/json\")\n\n    // Exécution de la requête\n    response, err := http.DefaultClient.Do(request)\n\n    // Erreur si route inacessible\n    if err != nil {\n        t.Error(err)\n    }\n\n    // Erreur si code HTTP différent de 200\n    if response.StatusCode != 200 {\n        t.Errorf(\"Success expected: %d\", response.StatusCode)\n    }\n}</code></pre>\n<ol>\n<li>On stocke dans une variable le contenu de la ligne que l'on souhaite ajouter ;</li>\n<li>On modifie ce contenu pour le rendre lisible au format \"NewReader\" ;</li>\n<li>\n<p>On déclare la requête avec 3 paramètres :</p>\n<ul>\n<li>le type de la route : \"PUT\" ;</li>\n<li>l'URL de la route avec l'id en paramètre ;</li>\n<li>le contenu ;</li>\n</ul>\n</li>\n<li>On spécifie ce contenu au format JSON (afin d'éviter une erreur HTTP 422) ;</li>\n<li>S'il y a une erreur pour contacter la route, alors le test affichera une erreur ;</li>\n<li>Si le code HTTP n'est pas 200 alors le test affichera une erreur.</li>\n</ol>\n<h4 id=\"tester-la-suppression-dune-ligne\"><a href=\"#tester-la-suppression-dune-ligne\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Tester la suppression d'une ligne</h4>\n<pre class=\"language-golang\"><code class=\"language-golang\">func TestDeleteUser(t *testing.T) {\n    // Contenu à soumettre vide\n    reader = strings.NewReader(\"\")\n\n    // Déclaration de la requête : type, URL, contenu\n    request, err := http.NewRequest(\"DELETE\", usersUrlId, reader)\n\n    // Exécution de la requête\n    response, err := http.DefaultClient.Do(request)\n\n    // Erreur si route inacessible\n    if err != nil {\n        t.Error(err)\n    }\n\n    // Erreur si code HTTP différent de 200\n    if response.StatusCode != 200 {\n        t.Errorf(\"Success expected: %d\", response.StatusCode)\n    }\n}</code></pre>\n<ol>\n<li>On stocke dans une variable aucun contenu;</li>\n<li>\n<p>On déclare la requête avec 3 paramètres :</p>\n<ul>\n<li>le type de la route : \"DELETE\" ;</li>\n<li>l'URL de la route avec l'id en paramètre ;</li>\n<li>le contenu (aucun) ;</li>\n</ul>\n</li>\n<li>S'il y a une erreur pour contacter la route, alors le test affichera une erreur ;</li>\n<li>Si le code HTTP n'est pas 200 alors le test affichera une erreur.</li>\n</ol>\n<h3 id=\"lancer-la-série-des-tests\"><a href=\"#lancer-la-s%C3%A9rie-des-tests\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Lancer la série des tests</h3>\n<p>Dans votre terminal, allez dans le dossier \"api\" et lancez le test avec la commande <code class=\"language-text\">go test api_test.go</code>. Si tout est ok, vous devriez avoir un message de ce genre : <code class=\"language-text\">ok command-line-arguments 0.210s</code>.`</p>\n<p><img src=\"https://i.giphy.com/ZKf5OzdXdjtRu.gif\"></p>\n<p>Pour voir tout le processus des tests : <code class=\"language-text\">go test -bench=.</code>.</p>\n<p>Dans le dossier \"api\" vous avez remarqué qu'un nouveau fichier a fait son apparition, il s'agit du fichier \"data.db\" dédié aux tests.</p>\n<p>Remarque : si vous utilisez le protocole de versionning Git, n'oubliez pas d'ajouter le chemin du fichier de base de données de test dans le fichier \".gitignore\".</p>\n<h2 id=\"options-de-configurations\"><a href=\"#options-de-configurations\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Options de configurations</h2>\n<p>Dans cette partie, nous allons utiliser la notion de \"middleware\". C'est une fonction qui permet d'être appelée depuis une ou plusieurs fonctions.</p>\n<h3 id=\"cors-cross-origin-ressource-sharing\"><a href=\"#cors-cross-origin-ressource-sharing\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>CORS (Cross Origin Ressource Sharing)</h3>\n<p>Pour établir une communication interdomaine, il faut autoriser la connexion en activant le CORS sinon vous aurez un message explicite dans Firefox.</p>\n<pre class=\"language-text\"><code class=\"language-text\">Blocage d’une requête multi-origines (Cross-Origin Request) : la politique « Same Origin » ne permet pas de consulter la ressource distante située sur http://localhost:3000/api/v1/users. Raison : l’en-tête CORS « Access-Control-Allow-Origin » est manquant.</code></pre>\n<p>Message d'erreur testé avec le code Javascript ci-dessous.</p>\n<pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> xhr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">XMLHttpRequest</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nxhr<span class=\"token punctuation\">.</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">'GET'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'http://localhost:3000/api/v1/users'</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nxhr<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">onreadystatechange</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>xhr<span class=\"token punctuation\">.</span>readyState <span class=\"token operator\">==</span> <span class=\"token number\">4</span> <span class=\"token operator\">&amp;&amp;</span> xhr<span class=\"token punctuation\">.</span>status <span class=\"token operator\">==</span> <span class=\"token string\">'200'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">table</span><span class=\"token punctuation\">(</span><span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>xhr<span class=\"token punctuation\">.</span>responseText<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\nxhr<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>Au niveau local, dans la ou les route(s) concernée(s).</p>\n<pre class=\"language-golang\"><code class=\"language-golang\">c.Writer.Header().Add(\"Access-Control-Allow-Origin\", \"*\")\nc.Next()</code></pre>\n<p>L'astérisque signifie que l'accès est autorisé pour n'importe quelle IP. Pour des raisons de sécurité, vous pouvez spécifier une adresse IP ou plusieurs, séparées par une virgule.</p>\n<p>Au niveau global, à partir d'un middleware, on créé une fonction nommée <code class=\"language-text\">Cors()</code>.</p>\n<pre class=\"language-golang\"><code class=\"language-golang\">func Cors() gin.HandlerFunc {\n    return func(c *gin.Context) {\n        c.Writer.Header().Add(\"Access-Control-Allow-Origin\", \"*\")\n        c.Next()\n    }\n}</code></pre>\n<p>Puis on appel notre fonction <code class=\"language-text\">Cors()</code> dans la fonction <code class=\"language-text\">Handlers()</code> du fichier \"api.go\".</p>\n<pre class=\"language-golang\"><code class=\"language-golang\">// Activation du CORS\nr.Use(Cors())</code></pre>\n<p>Coté test unitaire, ça donne la vérification du header \"Access-Control-Allow-Origin\".</p>\n<pre class=\"language-golang\"><code class=\"language-golang\">if response.Header.Get(\"Access-Control-Allow-Origin\") != \"*\" {\n    t.Error(\"No CORS\")\n}</code></pre>\n<h3 id=\"activer-options\"><a href=\"#activer-options\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Activer OPTIONS</h3>\n<p>Par défaut, lorsque vous allez essayer de faire un requête vers une route de type POST, PUT ou DELETE, un exemple de message ci-dessous apparaitra sur Firefox.</p>\n<pre class=\"language-text\"><code class=\"language-text\">Blocage d’une requête multi-origines (Cross-Origin Request) : la politique « Same Origin » ne permet pas de consulter la ressource distante située sur http://localhost:3000/api/v1/users. (Raison : échec du canal de pré-vérification des requêtes CORS.</code></pre>\n<p>Message d'erreur testé avec le code Javascript ci-dessous.</p>\n<pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> xhr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">XMLHttpRequest</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nxhr<span class=\"token punctuation\">.</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">'POST'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'http://localhost:3000/api/v1/users'</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nxhr<span class=\"token punctuation\">.</span><span class=\"token function\">setRequestHeader</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Content-type'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'application/json;charset=UTF-8'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nxhr<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> name<span class=\"token punctuation\">:</span> <span class=\"token string\">\"Jo\"</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p><img src=\"https://i.giphy.com/cAEm5rSuuBEGY.gif\"></p>\n<p>Alors oui ce message est ambigüe car on a activé le CORS pour toutes les routes. En fait, Firefox ou votre navigateur favori ne trouve pas la route de type \"OPTIONS\". En regardant de plus près dans le terminal de Gin, cette route est effectivement déclarée comme 404.<br>\nPour remédier à ce problème, on ajoute 2 routes de type \"OPTIONS\", la première pour POST et la seconde pour PUT et DELETE.</p>\n<pre class=\"language-golang\"><code class=\"language-golang\">v1Users.OPTIONS(\"\", OptionsUser)    // POST\nv1Users.OPTIONS(\":id\", OptionsUser) // PUT, DELETE</code></pre>\n<p>Ces dernières pointent toutes les deux sur la même fonction, \"OptionsUser\".</p>\n<pre class=\"language-golang\"><code class=\"language-golang\">func OptionsUser(c *gin.Context) {\n    c.Writer.Header().Set(\"Access-Control-Allow-Methods\", \"DELETE, POST, PUT\")\n    c.Writer.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type\")\n    c.Next()\n}</code></pre>\n<p>Coté tests unitaires, ça donne la vérification du header \"Access-Control-Allow-Methods\" ainsi que \"Access-Control-Allow-Headers\"</p>\n<pre class=\"language-golang\"><code class=\"language-golang\">if response.Header.Get(\"Access-Control-Allow-Methods\") != \"DELETE, POST, PUT\" {\n    t.Error(\"Access-Control-Allow-Methods is wrong :(\")\n}\n\nif response.Header.Get(\"Access-Control-Allow-Headers\") != \"Content-Type\" {\n    t.Error(\"Access-Control-Allow-Headers is wrong :(\")\n}</code></pre>\n<h3 id=\"authentification-avec-un-token\"><a href=\"#authentification-avec-un-token\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Authentification avec un token</h3>\n<p>Le but du token c'est de donner un identifiant généré aléatoirement depuis un formulaire d'inscription. Le serveur vérifie ensuite si le token existe bien dans la base de données.<br>\nOn met en place un middleware nommé <code class=\"language-text\">TokenAuthMiddleware()</code>.</p>\n<pre class=\"language-golang\"><code class=\"language-golang\">func TokenAuthMiddleware() gin.HandlerFunc {\n    return func(c *gin.Context) {\n        // Récupération du paramètre \"token\" dans une variable\n        token := c.Request.FormValue(\"token\")\n\n        // Token vide\n        if token == \"\" {\n            c.JSON(403, gin.H{\"error\": \"Access denied, API token required\"})\n            c.Abort()\n            return\n        }\n\n        // Vérification de la valeur du token\n        if token != \"mon_super_token\" {\n            c.JSON(401, gin.H{\"error\": \"Invalid API token\"})\n            c.Abort()\n            return\n        }\n\n        c.Next()\n    }\n}</code></pre>\n<p>On récupère le champ token nommé \"token\" via la fonction <code class=\"language-text\">c.Request.FormValue()</code>. S'il est vide ou si le token n'est pas bon, on renvoit une erreur 403 ou une 401 en personnalisant le message d'erreur.</p>\n<p>On peut utiliser le middleware en local.</p>\n<pre class=\"language-golang\"><code class=\"language-golang\">v1Users.GET(\"\", TokenAuthMiddleware(), GetUsers)</code></pre>\n<p>Ou en global dans la déclaration du groupe de routes.</p>\n<pre class=\"language-golang\"><code class=\"language-golang\">v1Users := r.Group(\"api/v1/users\", TokenAuthMiddleware())</code></pre>\n<p>Pour communiquer avec l'API, on met le token en paramètre dans l'URL concernée <a href=\"http://localhost:3000/api/v1/users?token=mon_super_token\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http://localhost:3000/api/v1/users?token=mon_super_token</a>. Bien entendu, il existe d'autre solutions comme HTTP authentification (Basic ou Digest), Oauth, Auth, OpenID et d'autres selon vos besoins.</p>\n<h2 id=\"conclusion\"><a href=\"#conclusion\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Conclusion</h2>\n<p>Rapide à mettre en place une fois la structure définie en amont, les routes sont gérées en aval avec le micro framework accompagnées des requêtes SQL adéquates. Vous pouvez désormais vous concentrer sur vos applications SPA (Single Page Application) et mobiles (Android, IOS, Windows Phone, etc...). Pour aller plus loin, vous pouvez activer HTTPS ce qui activera HTTP 2 pour vous routes (seulement à partir de Go 1.6).</p>\n<h2 id=\"sources\"><a href=\"#sources\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Sources</h2>\n<ul>\n<li>Espace de travail : <a href=\"https://golang.org/doc/code.html#Workspaces\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://golang.org/doc/code.html#Workspaces</a></li>\n<li>Gin : <a href=\"https://github.com/gin-gonic/gin\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://github.com/gin-gonic/gin</a></li>\n<li>Pilote SQLite : <a href=\"https://github.com/mattn/go-sqlite3\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://github.com/mattn/go-sqlite3</a></li>\n<li>Gorm : <a href=\"http://jinzhu.me/gorm\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http://jinzhu.me/gorm</a></li>\n<li>S'en sortir avec SQL sur Go : <a href=\"http://go-database-sql.org\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http://go-database-sql.org</a></li>\n</ul>\n"}},"context":{}}