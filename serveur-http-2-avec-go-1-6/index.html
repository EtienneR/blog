<!DOCTYPE html>
<html data-html-server-rendered="true" lang="en" data-vue-tag="lang">
  <head>
    <title>Serveur HTTP 2 avec Go 1.6 - https://etienner.github.io</title><meta name="gridsome:hash" content="41452752fefa88bad284d1f2761f45ec58a3a74c"><meta data-vue-tag="ssr" charset="utf-8"><meta data-vue-tag="ssr" name="generator" content="Gridsome v0.7.2"><meta data-vue-tag="ssr" data-key="viewport" name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"><meta data-vue-tag="ssr" data-key="format-detection" name="format-detection" content="telephone=no"><meta data-vue-tag="ssr" name="description" content="Bonne nouvelle, depuis la version 1.6 de Go, il est possible d&#x27;implémenter le HTTP/2, autrement dit, le futur de HTTP/1.1 existant depuis plus d&#x27;une décennie (1994 pour la version 1 et de 1997 à 2014"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="16x16" href="/assets/static/favicon.ce0531f.9bb7ffa.png"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="32x32" href="/assets/static/favicon.ac8d93a.9bb7ffa.png"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="96x96" href="/assets/static/favicon.b9532cc.9bb7ffa.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="76x76" href="/assets/static/favicon.f22e9f3.9bb7ffa.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="152x152" href="/assets/static/favicon.62d22cb.9bb7ffa.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="120x120" href="/assets/static/favicon.1539b60.9bb7ffa.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="167x167" href="/assets/static/favicon.dc0cdc5.9bb7ffa.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="180x180" href="/assets/static/favicon.7b22250.9bb7ffa.png"><noscript data-vue-tag="ssr"><style>.g-image--loading{display:none;}</style></noscript><link rel="preload" href="/assets/css/0.styles.2ee79837.css" as="style"><link rel="preload" href="/assets/js/app.06de8649.js" as="script"><link rel="preload" href="/assets/js/page--src--templates--post-vue.6a9fe53b.js" as="script"><link rel="prefetch" href="/assets/js/page--node-modules--gridsome--app--pages--404-vue.14b4f713.js"><link rel="prefetch" href="/assets/js/page--src--pages--index-vue.d116fa6d.js"><link rel="stylesheet" href="/assets/css/0.styles.2ee79837.css">
  </head>
  <body >
    <div data-server-rendered="true" id="app"><header><div class="container text-center"><strong><a href="/" title="Accueil" class="active">Etienne ROUZEAUD - Développeur Web</a></strong></div></header><div class="text-center title"><h1 class="display-5">Serveur HTTP 2 avec Go 1.6</h1><p><em>Posté le <span>02 mars 2016</span></em></p></div><div class="container"><article class="mt-4"><p>Bonne nouvelle, depuis la version 1.6 de Go, il est possible d'implémenter le HTTP/2, autrement dit, le futur de HTTP/1.1 existant depuis plus d'une décennie (1994 pour la version 1 et de 1997 à 2014 pour la version 1.1). Cette nouvelle version siglée RFC 7540 propulse le chargement des fichiers en multiplexage avec des entêtes compressées. Autant vous dire que le temps de chargement est au rendez-vous pour la moyenne des sites actuels dont les pages pèsent environ 2 Mo avec 60 / 80 requêtes. Pas de panique, les methodes (GET, POST, PUT, DELETE, etc...) ne changent pas ainsi que les codes de statuts, les entêtes et la négociation.</p>
<p><img class="g-image g-image--lazy g-image--loading" src="data:image/svg+xml,%3csvg fill='none' viewBox='0 0 480 341' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-108'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='40'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-108)' width='480' height='341' xlink:href='data:image/jpeg%3bbase64%2c/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAtAEADASIAAhEBAxEB/8QAHAABAAICAwEAAAAAAAAAAAAABgEFAgMABAcI/8QANBAAAQIFAgQEAwcFAAAAAAAAAQIDAAQFBhESIRMiMVEHQXKxFZGhFBdSYWNxwSMyYqKy/8QAFwEBAQEBAAAAAAAAAAAAAAAAAQACA//EACQRAAIBAwIGAwAAAAAAAAAAAAECAAMRIRIxExRBUZHRBGGh/9oADAMBAAIRAxEAPwD6PWoIQpajhKQST2AjS9Py7LqWluHiHPKltSj0z5DsRHVr1Up9Mpy3KtMolpZz%2bkVLPUqBGPeCyb9sqnLTw65Io0rLgQ25kAlISdgOwjJqKuCZsIzZAi4VaSPCPG2dzwzoUAoAZJBxuPzjtS77UyjWysLTnBx5Hsfzga3e1oTMsgN1mX0ISEZUoglOQcbjzxvG2TvW0pNhQRcUmU5yrjTYUrPfffJiV1bYyalUXLAiMesRBhN/2spouCvU3QOqi%2bAPrGEv4g2vMqIZrUkrHU68D5kYhLqNzIUntexigxgonuYo6feVu1J7gyVZp7zv4EzCc/LMXLbrbydTTiFjulQPtAGDZECpG4lfdFu0y56aJCsy4flgsOBOccw6H6mCg8IbP0hIpriR/hMLT7EQ5nRMKQ19lKQvioKtfTRnm%2bkVqJWpLYXxpp5LxYUEltYCUualYIG%2b2nT1zj94SAd4h2XCmF/uds7fVTXF%2buYWr3Ma/uctVKSllqdYH6UwUkQ0lpF1l6ae4zilLaShpCnCUoOnf/bfO8diUTMIePGJKAy2kc2eYatR/wCd4iincSWrUXKkiAJbwZtZl3iONzb6/wATr2o/MjMbHvBy0XlEuSk0rPkqaWoD9sx6NqiCoQCkg6RNaoc6jPJJvwMoC1qMnUKpKpPRAdCgn5iEvh1YbNlIng1UZueVNKSSp/ACEpzgADbO5yYa5iIuGoNwJGtUYaSSRKi4JCrThZNHq4p%2bjOsKYDgX269IqPhV4oHLcUiv1SULhE5gKA5nRPkMg0gDwPUHGXvlrGioUV/1sLR7Rzj3y1/dJ0R/0vLT7wxiMxcP7Mea7qPHqDzVbxQOa3pJw/pzo/kRHx660DntQK9E4g/xDCIziLQe5hzC9aY/fcqbfqc9UEvfEaRMU1SCAkOrSrXnrjHaLbzjEqjArOY2BYZnFiGa4Fp//9k=' /%3e%3c/svg%3e" width="480" data-srcset="/assets/static/http1.1_vs_http2.82a2fbd.e2913c8.jpg 480w, /assets/static/http1.1_vs_http2.82a2fbd.e2913c8.jpg 480w" data-sizes="(max-width: 480px) 100vw, 480px" data-src="/assets/static/http1.1_vs_http2.82a2fbd.e2913c8.jpg"><noscript><img class="g-image g-image--lazy g-image--loaded" src="/assets/static/http1.1_vs_http2.82a2fbd.e2913c8.jpg" width="480"></noscript></p>
<p>Pour pouvoir mettre en place HTTP/2, il faut exécuter le serveur avec le chiffrement TLS, autrement dit HTTPS.</p>
<h2 id="préparation-de-la-clef-et-du-certificat"><a href="#pr%C3%A9paration-de-la-clef-et-du-certificat" aria-hidden="true"><span class="icon icon-link"></span></a>Préparation de la clef et du certificat</h2>
<p>Pour que TLS fonctionne correctement, il faut générer un fichier qui va contenir la clef publique et un certificat. On utilise l'utilitaire "openssl" à la racine du projet pour générer nos 2 fichiers.
On commence par générer la clef privée : <code class="language-text">openssl genrsa -out localhost.key 2048</code> afin de générer le certificat : <code class="language-text">openssl req -new -x509 -key localhost.key -out localhost.pem -days 730</code></p>
<ul>
<li>"-x509" : le cryptage utilisé ;</li>
<li>"-key localhost.key" : le fichier de la clef publique ;</li>
<li>"out localhost.pem" : le fichier du certificat ;</li>
<li>"-days 365" : correspond au nombre de jour (ici 1 an) de validité du certificat.</li>
</ul>
<h2 id="configurer-http2"><a href="#configurer-http2" aria-hidden="true"><span class="icon icon-link"></span></a>Configurer HTTP/2</h2>
<p>Tout d'abord si votre version de Go (<code class="language-text">go version</code>) est inférieur à la 1.6, il faut télécharger la librairie mise à disposition pour HTTP/2 : <code class="language-text">go get golang.org/x/net/http2</code> pour l'importer avec les autres librairies dont nous aurons besoin par la suite.</p>
<pre class="language-golang"><code class="language-golang">package main

import (
    "fmt"
    "log"
    "net/http"

    // Go < 1.6
    "golang.org/x/net/http2"
)</code></pre>
<p>Si vous travaillez sur la version 1.6 ou +, vous n'avez pas besoin de suivre cette partie.<br>
Dans la fonction principale "main()", on déclare une variable "s" de type "http.Server". On active les logs dans le terminal du serveur en passant la valeur de "http2.VerboseLogs" à "true" sans oublier "http2.ConfigureServer" dans laquelle on met en premier paramètre l'expression "&#x26;s" et en second "nil".</p>
<pre class="language-golang"><code class="language-golang">func main() {
    // Configuration de HTTP2 pour Go < 1.6
    var s http.Server
    http2.VerboseLogs = true
    http2.ConfigureServer(&s, nil)

    // Suite du code
)</code></pre>
<h2 id="création-et-appel-dune-route"><a href="#cr%C3%A9ation-et-appel-dune-route" aria-hidden="true"><span class="icon icon-link"></span></a>Création et appel d'une route</h2>
<p>Pour afficher un résultat dans la route d'accueil, on créé une nouvelle fonction "indexHandler" avec les paramètres de la librairie http ("w http.ResponseWriter, r *http.Request").</p>
<pre class="language-golang"><code class="language-golang">// Route d'accueil
func indexHandler(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "text/plain; charset=UTF-8")
    fmt.Fprintln(w, "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.")
}</code></pre>
<p>Rien d'extraordinaire, on affiche seulement du texte au format UTF-8 via "fmt.Fprintln()". Puis dans notre fonction "main()", on appelle cette route dans la fonction "http.HandleFunc()".</p>
<pre class="language-golang"><code class="language-golang">func main() {
    // Configuration de HTTP2 pour Go < 1.6
    var s http.Server
    http2.VerboseLogs = true
    http2.ConfigureServer(&s, nil)

    // Appel de la route d'accueil
    http.HandleFunc("/", indexHandler)

    // Suite du code
}</code></pre>
<h2 id="listenandservetls"><a href="#listenandservetls" aria-hidden="true"><span class="icon icon-link"></span></a>ListenAndServeTLS</h2>
<p>Maintenant que l'on a activé HTTP 2 et appelé notre unique route, il ne manque plus que le "démarreur" de notre serveur. Pour cela on utilise, la fonction "http.ListenAndServeTLS()" dans laquelle on indique le port (443 par défaut), le nom de notre certificat ("localhost.pem"), la clef publique ("localhost.key") et "nil".</p>
<pre class="language-golang"><code class="language-golang">func main() {
    // Configuration de HTTP2 pour Go < 1.6
    var s http.Server
    http2.VerboseLogs = true
    http2.ConfigureServer(&s, nil)

    // Appel de la route d'accueil
    http.HandleFunc("/", indexHandler)

    // Lancement du serveur HTTPS
    err := http.ListenAndServeTLS(":443", "localhost.pem", "localhost.key", nil)
    if err != nil {
        log.Fatal("ListenAndServe: ", err)
    }
}</code></pre>
<p>S'il y a une erreur au lancement du serveur (mauvais paramètre, fichier manquant, etc..) elle s'affichera grâce à "log.Fatal()".</p>
<h2 id="lancement-du-serveur"><a href="#lancement-du-serveur" aria-hidden="true"><span class="icon icon-link"></span></a>Lancement du serveur</h2>
<p>Lancez votre serveur avec <code class="language-text">go run main.go</code>.</p>
<p>Dans votre navigateur Internet, accédez à votre serveur via <a href="https://localhost" target="_blank" rel="nofollow noopener noreferrer">https://localhost</a> (et non <a href="http://localhost" target="_blank" rel="nofollow noopener noreferrer">http://localhost</a> !!!). A la première connexion, vous devez accepter le certificat demandé par votre navigateur.</p>
<p>Remarque : votre navigateur vous informe que le certificat est dangereux. C'est tout à fait juste car ce dernier n'est pas signé par une autorité compétente.</p>
<h3 id="linux"><a href="#linux" aria-hidden="true"><span class="icon icon-link"></span></a>Linux</h3>
<p>Sur Linux lorsque vous tentez de lancez le serveur avec le port 443 vous avez le droit à l'erreur suivante : <code class="language-text">ListenAndServe: listen tcp :443: bind: permission denied</code>. En effet, il faut lancer la commande avec les privilèges de sudo.
Pour résoudre ce problème d'autorisation, ouvrez le fichier de configuration de l'utilitaire sudo : <code class="language-text">sudo vim /etc/sudoers</code> et ajoutez les 2 lignes ci-dessous :</p>
<pre class="language-text"><code class="language-text">Defaults env_keep +=&quot;GOPATH&quot;
Defaults env_keep +=&quot;GOROOT&quot;</code></pre>
<p>Puis enregistrez cette modification avec "wq!" et lancez le serveur avec <code class="language-text">sudo go run main.go</code>.</p>
<h2 id="sources"><a href="#sources" aria-hidden="true"><span class="icon icon-link"></span></a>Sources</h2>
<ul>
<li>Fonction ConfigureServer de golang.org/x/net/http2 : <a href="https://godoc.org/golang.org/x/net/http2#ConfigureServer" target="_blank" rel="nofollow noopener noreferrer">https://godoc.org/golang.org/x/net/http2#ConfigureServer</a></li>
<li>Fonction ListenAndServeTLS : <a href="https://golang.org/pkg/net/http/#ListenAndServeTLS" target="_blank" rel="nofollow noopener noreferrer">https://golang.org/pkg/net/http/#ListenAndServeTLS</a></li>
<li>A propos du fichier sudoers <a href="https://doc.ubuntu-fr.org/sudoers" target="_blank" rel="nofollow noopener noreferrer">https://doc.ubuntu-fr.org/sudoers</a></li>
<li>Des outils pour tester HTTP 2<a href="https://blog.cloudflare.com/tools-for-debugging-testing-and-using-http-2" target="_blank" rel="nofollow noopener noreferrer">https://blog.cloudflare.com/tools-for-debugging-testing-and-using-http-2</a></li>
<li>"HTTP/2 : quels sont les nouveautés et les gains ?" <a href="https://devcentral.f5.com/articles/http2-est-l-quels-sont-les-gains-14945" target="_blank" rel="nofollow noopener noreferrer">https://devcentral.f5.com/articles/http2-est-l-quels-sont-les-gains-14945</a></li>
</ul>
</article></div><footer class="text-white mt-4"><ul class="nav nav-pills justify-content-center"><li><a href="https://github.com/etienner" target="_blank" class="nav-link">Github</a></li><li><a href="https://medium.com/@etiennerouzeaud" target="_blank" class="nav-link">Medium</a></li><li><a href="https://twitter.com/etiennerouzeaud" target="_blank" class="nav-link">Twitter</a></li></ul></footer></div>
    <script>window.__INITIAL_STATE__={"data":{"post":{"title":"Serveur HTTP 2 avec Go 1.6","date":"2 March 2016","content":"\u003Cp\u003EBonne nouvelle, depuis la version 1.6 de Go, il est possible d'implémenter le HTTP\u002F2, autrement dit, le futur de HTTP\u002F1.1 existant depuis plus d'une décennie (1994 pour la version 1 et de 1997 à 2014 pour la version 1.1). Cette nouvelle version siglée RFC 7540 propulse le chargement des fichiers en multiplexage avec des entêtes compressées. Autant vous dire que le temps de chargement est au rendez-vous pour la moyenne des sites actuels dont les pages pèsent environ 2 Mo avec 60 \u002F 80 requêtes. Pas de panique, les methodes (GET, POST, PUT, DELETE, etc...) ne changent pas ainsi que les codes de statuts, les entêtes et la négociation.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg class=\"g-image g-image--lazy g-image--loading\" src=\"data:image\u002Fsvg+xml,%3csvg fill='none' viewBox='0 0 480 341' xmlns='http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg' xmlns:xlink='http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-108'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='40'\u002F%3e%3c\u002Ffilter%3e%3c\u002Fdefs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-108)' width='480' height='341' xlink:href='data:image\u002Fjpeg%3bbase64%2c\u002F9j\u002F2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj\u002F2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj\u002FwAARCAAtAEADASIAAhEBAxEB\u002F8QAHAABAAICAwEAAAAAAAAAAAAABgEFAgMABAcI\u002F8QANBAAAQIFAgQEAwcFAAAAAAAAAQIDAAQFBhESIRMiMVEHQXKxFZGhFBdSYWNxwSMyYqKy\u002F8QAFwEBAQEBAAAAAAAAAAAAAAAAAQACA\u002F\u002FEACQRAAIBAwIGAwAAAAAAAAAAAAECAAMRIRIxExRBUZHRBGGh\u002F9oADAMBAAIRAxEAPwD6PWoIQpajhKQST2AjS9Py7LqWluHiHPKltSj0z5DsRHVr1Up9Mpy3KtMolpZz%2bkVLPUqBGPeCyb9sqnLTw65Io0rLgQ25kAlISdgOwjJqKuCZsIzZAi4VaSPCPG2dzwzoUAoAZJBxuPzjtS77UyjWysLTnBx5Hsfzga3e1oTMsgN1mX0ISEZUoglOQcbjzxvG2TvW0pNhQRcUmU5yrjTYUrPfffJiV1bYyalUXLAiMesRBhN\u002F2spouCvU3QOqi%2bAPrGEv4g2vMqIZrUkrHU68D5kYhLqNzIUntexigxgonuYo6feVu1J7gyVZp7zv4EzCc\u002FLMXLbrbydTTiFjulQPtAGDZECpG4lfdFu0y56aJCsy4flgsOBOccw6H6mCg8IbP0hIpriR\u002FhMLT7EQ5nRMKQ19lKQvioKtfTRnm%2bkVqJWpLYXxpp5LxYUEltYCUualYIG%2b2nT1zj94SAd4h2XCmF\u002Fuds7fVTXF%2buYWr3Ma\u002FuctVKSllqdYH6UwUkQ0lpF1l6ae4zilLaShpCnCUoOnf\u002FbfO8diUTMIePGJKAy2kc2eYatR\u002FwCd4iincSWrUXKkiAJbwZtZl3iONzb6\u002FwATr2o\u002FMjMbHvBy0XlEuSk0rPkqaWoD9sx6NqiCoQCkg6RNaoc6jPJJvwMoC1qMnUKpKpPRAdCgn5iEvh1YbNlIng1UZueVNKSSp\u002FACEpzgADbO5yYa5iIuGoNwJGtUYaSSRKi4JCrThZNHq4p%2bjOsKYDgX269IqPhV4oHLcUiv1SULhE5gKA5nRPkMg0gDwPUHGXvlrGioUV\u002F1sLR7Rzj3y1\u002FdJ0R\u002F0vLT7wxiMxcP7Mea7qPHqDzVbxQOa3pJw\u002Fpzo\u002FkRHx660DntQK9E4g\u002FxDCIziLQe5hzC9aY\u002Ffcqbfqc9UEvfEaRMU1SCAkOrSrXnrjHaLbzjEqjArOY2BYZnFiGa4Fp\u002F\u002F9k=' \u002F%3e%3c\u002Fsvg%3e\" width=\"480\" data-srcset=\"\u002Fassets\u002Fstatic\u002Fhttp1.1_vs_http2.82a2fbd.e2913c8.jpg 480w, \u002Fassets\u002Fstatic\u002Fhttp1.1_vs_http2.82a2fbd.e2913c8.jpg 480w\" data-sizes=\"(max-width: 480px) 100vw, 480px\" data-src=\"\u002Fassets\u002Fstatic\u002Fhttp1.1_vs_http2.82a2fbd.e2913c8.jpg\"\u003E\u003Cnoscript\u003E\u003Cimg class=\"g-image g-image--lazy g-image--loaded\" src=\"\u002Fassets\u002Fstatic\u002Fhttp1.1_vs_http2.82a2fbd.e2913c8.jpg\" width=\"480\"\u003E\u003C\u002Fnoscript\u003E\u003C\u002Fp\u003E\n\u003Cp\u003EPour pouvoir mettre en place HTTP\u002F2, il faut exécuter le serveur avec le chiffrement TLS, autrement dit HTTPS.\u003C\u002Fp\u003E\n\u003Ch2 id=\"préparation-de-la-clef-et-du-certificat\"\u003E\u003Ca href=\"#pr%C3%A9paration-de-la-clef-et-du-certificat\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EPréparation de la clef et du certificat\u003C\u002Fh2\u003E\n\u003Cp\u003EPour que TLS fonctionne correctement, il faut générer un fichier qui va contenir la clef publique et un certificat. On utilise l'utilitaire \"openssl\" à la racine du projet pour générer nos 2 fichiers.\nOn commence par générer la clef privée : \u003Ccode class=\"language-text\"\u003Eopenssl genrsa -out localhost.key 2048\u003C\u002Fcode\u003E afin de générer le certificat : \u003Ccode class=\"language-text\"\u003Eopenssl req -new -x509 -key localhost.key -out localhost.pem -days 730\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\"-x509\" : le cryptage utilisé ;\u003C\u002Fli\u003E\n\u003Cli\u003E\"-key localhost.key\" : le fichier de la clef publique ;\u003C\u002Fli\u003E\n\u003Cli\u003E\"out localhost.pem\" : le fichier du certificat ;\u003C\u002Fli\u003E\n\u003Cli\u003E\"-days 365\" : correspond au nombre de jour (ici 1 an) de validité du certificat.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch2 id=\"configurer-http2\"\u003E\u003Ca href=\"#configurer-http2\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EConfigurer HTTP\u002F2\u003C\u002Fh2\u003E\n\u003Cp\u003ETout d'abord si votre version de Go (\u003Ccode class=\"language-text\"\u003Ego version\u003C\u002Fcode\u003E) est inférieur à la 1.6, il faut télécharger la librairie mise à disposition pour HTTP\u002F2 : \u003Ccode class=\"language-text\"\u003Ego get golang.org\u002Fx\u002Fnet\u002Fhttp2\u003C\u002Fcode\u003E pour l'importer avec les autres librairies dont nous aurons besoin par la suite.\u003C\u002Fp\u003E\n\u003Cpre class=\"language-golang\"\u003E\u003Ccode class=\"language-golang\"\u003Epackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"net\u002Fhttp\"\n\n    \u002F\u002F Go \u003C 1.6\n    \"golang.org\u002Fx\u002Fnet\u002Fhttp2\"\n)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003ESi vous travaillez sur la version 1.6 ou +, vous n'avez pas besoin de suivre cette partie.\u003Cbr\u003E\nDans la fonction principale \"main()\", on déclare une variable \"s\" de type \"http.Server\". On active les logs dans le terminal du serveur en passant la valeur de \"http2.VerboseLogs\" à \"true\" sans oublier \"http2.ConfigureServer\" dans laquelle on met en premier paramètre l'expression \"&#x26;s\" et en second \"nil\".\u003C\u002Fp\u003E\n\u003Cpre class=\"language-golang\"\u003E\u003Ccode class=\"language-golang\"\u003Efunc main() {\n    \u002F\u002F Configuration de HTTP2 pour Go \u003C 1.6\n    var s http.Server\n    http2.VerboseLogs = true\n    http2.ConfigureServer(&s, nil)\n\n    \u002F\u002F Suite du code\n)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2 id=\"création-et-appel-dune-route\"\u003E\u003Ca href=\"#cr%C3%A9ation-et-appel-dune-route\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ECréation et appel d'une route\u003C\u002Fh2\u003E\n\u003Cp\u003EPour afficher un résultat dans la route d'accueil, on créé une nouvelle fonction \"indexHandler\" avec les paramètres de la librairie http (\"w http.ResponseWriter, r *http.Request\").\u003C\u002Fp\u003E\n\u003Cpre class=\"language-golang\"\u003E\u003Ccode class=\"language-golang\"\u003E\u002F\u002F Route d'accueil\nfunc indexHandler(w http.ResponseWriter, r *http.Request) {\n    w.Header().Set(\"Content-Type\", \"text\u002Fplain; charset=UTF-8\")\n    fmt.Fprintln(w, \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\")\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003ERien d'extraordinaire, on affiche seulement du texte au format UTF-8 via \"fmt.Fprintln()\". Puis dans notre fonction \"main()\", on appelle cette route dans la fonction \"http.HandleFunc()\".\u003C\u002Fp\u003E\n\u003Cpre class=\"language-golang\"\u003E\u003Ccode class=\"language-golang\"\u003Efunc main() {\n    \u002F\u002F Configuration de HTTP2 pour Go \u003C 1.6\n    var s http.Server\n    http2.VerboseLogs = true\n    http2.ConfigureServer(&s, nil)\n\n    \u002F\u002F Appel de la route d'accueil\n    http.HandleFunc(\"\u002F\", indexHandler)\n\n    \u002F\u002F Suite du code\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2 id=\"listenandservetls\"\u003E\u003Ca href=\"#listenandservetls\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EListenAndServeTLS\u003C\u002Fh2\u003E\n\u003Cp\u003EMaintenant que l'on a activé HTTP 2 et appelé notre unique route, il ne manque plus que le \"démarreur\" de notre serveur. Pour cela on utilise, la fonction \"http.ListenAndServeTLS()\" dans laquelle on indique le port (443 par défaut), le nom de notre certificat (\"localhost.pem\"), la clef publique (\"localhost.key\") et \"nil\".\u003C\u002Fp\u003E\n\u003Cpre class=\"language-golang\"\u003E\u003Ccode class=\"language-golang\"\u003Efunc main() {\n    \u002F\u002F Configuration de HTTP2 pour Go \u003C 1.6\n    var s http.Server\n    http2.VerboseLogs = true\n    http2.ConfigureServer(&s, nil)\n\n    \u002F\u002F Appel de la route d'accueil\n    http.HandleFunc(\"\u002F\", indexHandler)\n\n    \u002F\u002F Lancement du serveur HTTPS\n    err := http.ListenAndServeTLS(\":443\", \"localhost.pem\", \"localhost.key\", nil)\n    if err != nil {\n        log.Fatal(\"ListenAndServe: \", err)\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003ES'il y a une erreur au lancement du serveur (mauvais paramètre, fichier manquant, etc..) elle s'affichera grâce à \"log.Fatal()\".\u003C\u002Fp\u003E\n\u003Ch2 id=\"lancement-du-serveur\"\u003E\u003Ca href=\"#lancement-du-serveur\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ELancement du serveur\u003C\u002Fh2\u003E\n\u003Cp\u003ELancez votre serveur avec \u003Ccode class=\"language-text\"\u003Ego run main.go\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\n\u003Cp\u003EDans votre navigateur Internet, accédez à votre serveur via \u003Ca href=\"https:\u002F\u002Flocalhost\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Flocalhost\u003C\u002Fa\u003E (et non \u003Ca href=\"http:\u002F\u002Flocalhost\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttp:\u002F\u002Flocalhost\u003C\u002Fa\u003E !!!). A la première connexion, vous devez accepter le certificat demandé par votre navigateur.\u003C\u002Fp\u003E\n\u003Cp\u003ERemarque : votre navigateur vous informe que le certificat est dangereux. C'est tout à fait juste car ce dernier n'est pas signé par une autorité compétente.\u003C\u002Fp\u003E\n\u003Ch3 id=\"linux\"\u003E\u003Ca href=\"#linux\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ELinux\u003C\u002Fh3\u003E\n\u003Cp\u003ESur Linux lorsque vous tentez de lancez le serveur avec le port 443 vous avez le droit à l'erreur suivante : \u003Ccode class=\"language-text\"\u003EListenAndServe: listen tcp :443: bind: permission denied\u003C\u002Fcode\u003E. En effet, il faut lancer la commande avec les privilèges de sudo.\nPour résoudre ce problème d'autorisation, ouvrez le fichier de configuration de l'utilitaire sudo : \u003Ccode class=\"language-text\"\u003Esudo vim \u002Fetc\u002Fsudoers\u003C\u002Fcode\u003E et ajoutez les 2 lignes ci-dessous :\u003C\u002Fp\u003E\n\u003Cpre class=\"language-text\"\u003E\u003Ccode class=\"language-text\"\u003EDefaults env_keep +=&quot;GOPATH&quot;\nDefaults env_keep +=&quot;GOROOT&quot;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EPuis enregistrez cette modification avec \"wq!\" et lancez le serveur avec \u003Ccode class=\"language-text\"\u003Esudo go run main.go\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\n\u003Ch2 id=\"sources\"\u003E\u003Ca href=\"#sources\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ESources\u003C\u002Fh2\u003E\n\u003Cul\u003E\n\u003Cli\u003EFonction ConfigureServer de golang.org\u002Fx\u002Fnet\u002Fhttp2 : \u003Ca href=\"https:\u002F\u002Fgodoc.org\u002Fgolang.org\u002Fx\u002Fnet\u002Fhttp2#ConfigureServer\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fgodoc.org\u002Fgolang.org\u002Fx\u002Fnet\u002Fhttp2#ConfigureServer\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003EFonction ListenAndServeTLS : \u003Ca href=\"https:\u002F\u002Fgolang.org\u002Fpkg\u002Fnet\u002Fhttp\u002F#ListenAndServeTLS\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fgolang.org\u002Fpkg\u002Fnet\u002Fhttp\u002F#ListenAndServeTLS\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003EA propos du fichier sudoers \u003Ca href=\"https:\u002F\u002Fdoc.ubuntu-fr.org\u002Fsudoers\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fdoc.ubuntu-fr.org\u002Fsudoers\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003EDes outils pour tester HTTP 2\u003Ca href=\"https:\u002F\u002Fblog.cloudflare.com\u002Ftools-for-debugging-testing-and-using-http-2\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fblog.cloudflare.com\u002Ftools-for-debugging-testing-and-using-http-2\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\"HTTP\u002F2 : quels sont les nouveautés et les gains ?\" \u003Ca href=\"https:\u002F\u002Fdevcentral.f5.com\u002Farticles\u002Fhttp2-est-l-quels-sont-les-gains-14945\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fdevcentral.f5.com\u002Farticles\u002Fhttp2-est-l-quels-sont-les-gains-14945\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n"}},"context":{}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script><script src="/assets/js/app.06de8649.js" defer></script><script src="/assets/js/page--src--templates--post-vue.6a9fe53b.js" defer></script>
  </body>
</html>
